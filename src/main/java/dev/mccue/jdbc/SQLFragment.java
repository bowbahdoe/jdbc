package dev.mccue.jdbc;

import org.intellij.lang.annotations.Language;
import org.intellij.lang.annotations.MagicConstant;

import java.sql.*;
import java.util.*;

/**
 * Represents a fragment of SQL. Stores both the text of the sql fragment
 * and the values for any placeholders.
 */
public final class SQLFragment {
    @Language("SQL")
    private final String sql;
    private final List<Object> parameters;

    private SQLFragment(String sql, List<?> parameters) {
        this.sql = Objects.requireNonNull(sql);
        this.parameters = Collections.unmodifiableList(new ArrayList<>(parameters));
    }

    public static SQLFragment of(String sql, List<?> parameters) {
        return new SQLFragment(sql, parameters);
    }

    public static SQLFragment of(String sql) {
        return new SQLFragment(sql, Collections.emptyList());
    }

    public String sql() {
        return sql;
    }

    public List<Object> parameters() {
        return parameters;
    }

    /**
     * Returns a {@link SQLFragment} of comma-separated {@code ?}s
     * for each of the items in the parameters list.
     * @param parameters The list of parameters.
     * @return A {@link SQLFragment}.
     */
    public static SQLFragment ofPlaceholders(List<?> parameters) {
        var sj = new StringJoiner(",");
        for (int i = 0; i < parameters.size(); i++) {
            sj.add("?");
        }
        return SQLFragment.of(sj.toString(), parameters);
    }

    public SQLFragment concat(SQLFragment other) {
        var params = new ArrayList<>(parameters);
        params.addAll(other.parameters);
        return SQLFragment.of(sql + other.sql, params);
    }

    public static SQLFragment join(String separator, Collection<SQLFragment> fragments) {
        var params = new ArrayList<>();
        var fragmentStr = new StringBuilder();

        var iter = fragments.iterator();
        while (iter.hasNext()) {
            var fragment = iter.next();
            params.addAll(fragment.parameters);
            fragmentStr.append(fragment.sql);
            if (iter.hasNext()) {
                fragmentStr.append(separator);
            }
        }
        return SQLFragment.of(fragmentStr.toString(), params);
    }

    @FunctionalInterface
    private interface PreparedStatementSupplier {
        PreparedStatement get(@Language("SQL") String sql) throws SQLException;
    }

    private PreparedStatement prepareStatement(PreparedStatementSupplier supplier)
            throws SQLException {
        // If an exception occurs when setting parameters, we should close
        // the PreparedStatement
        PreparedStatement stmtTemp = null;
        try {
            var stmt = supplier.get(sql);
            stmtTemp = stmt;
            int i = 1;
            for (var param : parameters) {
                if (param instanceof SettableParameter settableParameter) {
                    settableParameter.setParameter(stmt, i);
                } else {
                    stmt.setObject(i, param);
                }
                i++;
            }
            stmtTemp = null;
            return stmt;
        } finally {
            if (stmtTemp != null) {
                stmtTemp.close();
            }
        }
    }

    public PreparedStatement prepareStatement(Connection connection) throws SQLException {
        return prepareStatement(connection::prepareStatement);
    }

    public PreparedStatement prepareStatement(Connection connection, int[] columnIndexes) throws SQLException {
        return prepareStatement(sql -> connection.prepareStatement(sql, columnIndexes));
    }

    public PreparedStatement prepareStatement(
            Connection connection,
            @MagicConstant(intValues = {
                    Statement.RETURN_GENERATED_KEYS,
                    Statement.NO_GENERATED_KEYS
            }) int autoGeneratedKeys) throws SQLException {
        return prepareStatement(sql -> connection.prepareStatement(sql, autoGeneratedKeys));
    }

    public PreparedStatement prepareStatement(
            Connection connection,
            @MagicConstant(intValues = {
                    ResultSet.TYPE_FORWARD_ONLY,
                    ResultSet.TYPE_SCROLL_INSENSITIVE,
                    ResultSet.TYPE_SCROLL_SENSITIVE
            }) int resultSetType,
            @MagicConstant(intValues = {
                    ResultSet.CONCUR_READ_ONLY,
                    ResultSet.CONCUR_UPDATABLE
            }) int resultSetConcurrency) throws SQLException {
        return prepareStatement(sql -> connection.prepareStatement(sql, resultSetType, resultSetConcurrency));
    }

    public PreparedStatement prepareStatement(
            Connection connection,
            @MagicConstant(intValues = {
                    ResultSet.TYPE_FORWARD_ONLY,
                    ResultSet.TYPE_SCROLL_INSENSITIVE,
                    ResultSet.TYPE_SCROLL_SENSITIVE
            }) int resultSetType,
            @MagicConstant(intValues = {
                    ResultSet.CONCUR_READ_ONLY,
                    ResultSet.CONCUR_UPDATABLE
            }) int resultSetConcurrency,
            @MagicConstant(intValues = {
                    ResultSet.HOLD_CURSORS_OVER_COMMIT,
                    ResultSet.CLOSE_CURSORS_AT_COMMIT
            }) int resultSetHoldability
    ) throws SQLException {
        return prepareStatement(sql -> connection.prepareStatement(
                sql, resultSetType, resultSetConcurrency, resultSetHoldability
        ));
    }

    @Override
    public String toString() {
        return "SQLFragment[sql=" + sql + ", parameters=" + parameters + "]";
    }

    @Override
    public boolean equals(Object obj) {
        return obj instanceof SQLFragment fragment
                && fragment.sql.equals(sql)
                && Objects.equals(fragment.parameters, parameters);
    }

    @Override
    public int hashCode() {
        return Objects.hash(sql, parameters);
    }
}
